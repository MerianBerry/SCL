import sys
import os
import re
import glob
from pathlib import Path

print(sys.argv, flush=True)

sources: list[tuple[str, bool, bool]] = []
out: str = None
imp: str = None
skip: bool = False
for i, v in enumerate(sys.argv):
  if v == "-o":
    out = sys.argv[i+1]
    skip = True
    continue
  elif v == "-d":
    imp = sys.argv[i+1]
    skip = True
    continue
  elif i > 0 and not skip:
    s: int = 0
    while True:
      p = v.find(";")
      #print(f"{s}:{p}")
      if p < 0:
        sources.append(tuple([v, False, False]))
        break
      else:
        sources.append(tuple([v[:p], False, False]))
      v = v[p+1:]
      s = p + 1


  skip = False

if out == None:
  print("No output file given, using mini.hpp (-o <file>)")
  out = "mini.hpp"
if imp == None:
  print("No implementation definition given, using MINI_IMPL (-d <definition>)")
  imp = "MINI_IMPL"
if len(sources) == 0:
  print("No sources")
  exit(1)

print("out: " + out)
print("sources: ")
for v in sources:
  print("  " + v[0])

increg = re.compile(r'^[\t ]*#[\t ]*include "(\w+\.hp{,2})"$', re.M)
sincreg = re.compile(r'#include <\w+\.hp{,2}>')

# mini algorithm:
# For every source that hasnt been visited:
#   Find every "" include. add to tmplist
#   Insert tmplist just before entry in sources
#   Reset loop to front of sources
#
# For every header in sources:
#   If header hasnt been written yet:
#     Write to output, commenting "" includes
#
# For every code source in sources:
#   W/ implementation guard:
#   Write to output, commenting "" includes

# STAMP OF MEDIOCRE APPROVAL
#   Respects multilevel header dependencies, and their sequential nature
#   Only potential issue depending on implementation, the search phase can go on really long
#   Every header graph is considered and must be considered in full.
#     But dealing with duplicates can be lessened by saving what headers they include, and inserting that list.
#

# mini IMPLEMENTATION

def mini_search():
  i: int = 0
  while i < len(sources):
    v = sources[i]
    if (v[1]):
      i += 1
      continue
    sources[i] = [v[0], True, v[2]]
    with open(v[0]) as file:
      if not file:
        print(f"could not open {v[0]}")
        break
      content: str = file.read()
      m = increg.findall(content)
      if m == None:
        continue
      j: int = i
      for k in m:
        p = Path(v[0]).parent / k
        sources.insert(j, [p, False, True])
        j += 1
    i = 0

def header_write(fout):
  written: dict[str] = {}
  for v in sources:
    if not v[2] or written.get(v[0]):
      continue
    written[v[0]] = v[0]
    print(f"Writing header {v[0]}...")
    for line in open(v[0]):
      if increg.search(line) == None:
        fout.write(line)
      else:
        fout.write(f"/*{line[:len(line)-1]}*/\n")
    fout.write("\n\n")

def source_write(fout):
  fout.write(f"#ifdef {imp}\n\n")
  for v in sources:
    if v[2]:
      continue
    print(f"Writing source {v[0]}...")
    for line in open(v[0]):
      if increg.search(line) == None:
        fout.write(line)
      else:
        fout.write(f"/*{line[:len(line)-1]}*/\n")
    fout.write("\n\n")
  fout.write(f"#endif // #ifdef {imp}\n")

mini_search()

print("Mini searched:")
for v in sources:
  print("  " + str(v[0]))

fout = open(out, "w")
fout.write(f"/*  {Path(out).name} generated by mini.py  */\n\n/* clang-format off */\n\n")


header_write(fout)
source_write(fout)

fout.write("\n/* clang-format on */\n")
